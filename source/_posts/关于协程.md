---
title: 关于协程
toc: true
date: 2022-09-14 16:38:24
tags:
categories:
---
认识协程
<!--more-->
# 协程的由来
在早期的计算机系统中，进程是操作系统进行资源分配和调度的基本单位，也是程序执行的最小单位，每个进程都有其单独的内存空间，使得进程之间的内存相互独立。随着计算机的发展，越来越多的场景需要多任务并发执行，而进程的创建、切换、销毁开销大，且进程之间内存无法共享等问题无法满足复杂的场景需求，这些问题促使了线程的诞生。
线程是cpu调度和分派的基本单位，它可以理解为进程的一条执行路径。一个进程可以有一个或多个线程，线程之间共享内存空间，同时线程存在自己的私有工作空间以及上下文，极大的缩小了进程创建和切换带来的开销。而线程之间通过时间片轮转来分配cpu时间片，使得单核cpu也能做到“并发”的效果，这使得多任务并发的性能得到了很大的提高。
我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。但是线程仍然存在一定的问题：**系统线程会占用非常多的内存空间、过多的线程切换会占用大量的系统时间**。
协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
协程实际上就是在当前以抢占式线程的多任务并发机制为主的操作系统中，以协同式的调度思想来解决多任务问题，并且尽量的减少线程之间的切换开销，提升程序在高并发时的性能。

# 协程的实现
如今虽不敢说协程已经是红的发紫，但确实是越来越受到了大家的重视。协程已经成为大多数语言的标配，例如 Golang 里的 goroutine，JavaScript 里的 async/await，kotlin 里的 Continuation。尽管名称可能不同，但它们都可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await。
“有栈”和“无栈”的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的。这里是指协程是否可以在其任意嵌套函数中被挂起，此处的嵌套函数读者可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以。
## 有栈协程
### 栈
![图1](image_pic_1.png)
一般的函数调用过程如下：在函数调用之前主调函数会将函数参数和返回地址入栈，被调函数在执行之前会先将主调函数的ebp入栈，并在栈上新开辟一块内存用于存放局部变量等信息；当被调函数执行完毕之后，会执行退栈操作，找到函数退出之前的下一条指令的地址并将栈中存放的局部变量信息恢复，即可恢复原来主调函数被中断的执行过程。
我们看到函数通过函数返回语句实现执行权限的归还，通过栈中返回地址实现被中断执行流程的恢复，而有栈协程正是基于这一朴素的想法实现的：在有栈协程中，将每个并行事务看成是一个函数调用，而协程库负责把让出执行权时的协程的上下文缓存起来（即当时的栈包括局部变量、返回地址等），当协程被重新调度时，就把切出时的栈重新装载进去即可。
### 有栈协程的实现
如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。
有栈协程是可以在其任意嵌套函数中被挂起的——毕竟它都能保存和恢复自己完整的上下文了，那自然是在哪里被挂起都可以。而实现这些我们需要下面的操作：
1. 申请一段能存储上下文的内存空间。在保存上下文时，我们可以选择把上下文都拷贝到这段内存；亦或者直接将这段内存作为协程运行时的栈帧空间，这样就能避免拷贝带来的性能损失了。
```C++
// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的
char **init_ctx(char *func) {
    // 1.动态申请 CTX_SIZE 内存用于存储协程上下文    
    size_t size = sizeof(char *) * CTX_SIZE;
    char **ctx = malloc(size);
    memset(ctx, 0, size);

    // 2. 将 func 的地址作为其栈帧 return address 的初始值，    
    // 当 func 第一次被调度时，将从其入口处开始执行    
    *(ctx + CTX_SIZE - 1) = (char *) func;

    // 3. 需要预留 6 个寄存器内容的存储空间，    
    // 余下的内存空间均可以作为 func 的栈帧空间    
    *(ctx + CTX_SIZE - 6) = (char *) (ctx + CTX_SIZE - 7);
    return ctx + CTX_SIZE;
}
```
2. 保存寄存器的值的逻辑如下：
```C++
// 依次将各个寄存器的值存储；
// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的
movl %ebx,  -8(%eax)
movl %edi, -12(%eax)
movl %esi, -16(%eax)
movl %ebp, -20(%eax)
movl %esp, -24(%eax)
//  %esp  存储的是当前调用栈的顶部所在的地址，
// (%esp) 是顶部地址所指向的内存区域存储的值，
// 将这个值存储为 return address
movl (%esp), %ecx
movl %ecx, -4(%eax)
```
3. 恢复寄存器的值的逻辑如下：
```C++
// 依次将存储的值写入各个寄存器；
// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的
movl  -8(%eax), %ebx
movl -12(%eax), %edi
movl -16(%eax), %esi
movl -20(%eax), %ebp
movl -24(%eax), %esp
//  %esp  存储的是当前调用栈的顶部所在的地址，
// (%esp) 是顶部地址所指向的内存区域存储的值，
// 将存储的 return address 写入到该内存区域
movl -4(%eax), %ecx
movl %ecx, (%esp)
```
### 有栈协程的调用
基于上述两段汇编构造一个 void swap_ctx(char **current, char **next) 函数，分别传入 char **init_ctx(char *func) 构造好的上下文即可实现切换。为了方便使用，我们可以将 swap_ctx() 封装成 yield() 函数，在这个函数里简单实现了不同函数的调度逻辑。于是一个简单的例子便完成了：
```C++
char **MAIN_CTX;
char **NEST_CTX;
char **FUNC_CTX_1;
char **FUNC_CTX_2;

void nest_yield() {
    yield(); // 用于切换初始化的方法，具体可查看链接
//https://github.com/mthli/blog/blob/master/content/blog/stackful-stackless/stackful.c
}
void nest() {
    // 随机生成一个整数作为 tag    
    int tag = rand() % 100;
    for (int i = 0; i < 3; i++) {
        printf("nest, tag: %d, index: %d\n", tag, i);
        nest_yield();
    }
}
void func() {
    // 随机生成一个整数作为 tag    
    int tag = rand() % 100;
    for (int i = 0; i < 3; i++) {
        printf("func, tag: %d, index: %d\n", tag, i);
        yield();
    }
}
int main() {
    MAIN_CTX = init_ctx((char *) main);

    // 证明 nest() 可以在其任意嵌套函数中被挂起    
    NEST_CTX = init_ctx((char *) nest);

    // 证明同一个函数在不同的栈帧空间上运行    
    FUNC_CTX_1 = init_ctx((char *) func);
    FUNC_CTX_2 = init_ctx((char *) func);

    int tag = rand() % 100;
    for (int i = 0; i < 3; i++) {
        printf("main, tag: %d, index: %d\n", tag, i);
        yield();
    }

    free(MAIN_CTX - CTX_SIZE);
    free(NEST_CTX - CTX_SIZE);
    free(FUNC_CTX_1 - CTX_SIZE);
    free(FUNC_CTX_2 - CTX_SIZE);
    return 0;
}
```
编译后运行结果如下：
![图2](image_pic_2.jpeg)
## 无栈协程
有栈协程是基于函数切换上下文恢复的思路实现被中断协程的继续执行，但是这个上下文里面有返回地址，即下一条指令的地址，所以当程序发生改动重新编译生成，指令地址有可能发生改变，这种对于需要重新编译生成发布的发布场景支持并不友好，会因为程序指令地址的变化导致协程执行流的错乱。这时另外一种不基于上下文恢复的协程机制提供了一种新的思路。
无栈协程基于一个朴素的思想：是否我们可以通过给指令打标签的方式，告诉下一次指令需要从哪个标签开始执行，其中需要的变量我们存起来就好了？这样既解决了上下文切换很多不必要的操作，也解决了程序修改后指令地址改变导致的无法恢复的问题。
我们可以使用 switch 语句直接实现跳转而不是使用它来决定该执行哪条 goto 语句：
```C++
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: goto LABEL0;
        case 1: goto LABEL1;
        case 2: goto LABEL2;
    }
    LABEL0: // 函数开始执行
    for (i = 0; i < 10; i++) {
        state = 1; // 我们会跳转到 LABEL1
        return i;
        LABEL1: // 从上一次返回之后的地方开始执行
        state = 2;
        i += 1;
        return i;
        LABEL2:
        state = 3;
    }
}
```
我们试着调用的方法如下：
```C++
int main() {
    int i =function();
    printf("i:%d\n",i);
    i = function();
    printf("i:%d\n",i);
    i = function();
    printf("i:%d\n",i);
    i = function();
    printf("i:%d\n",i);
    i = function();
    printf("i:%d\n",i);
    return 0;
}
```
执行结果如下：
>i:0 
i:1 
i:2 
i:3 
i:4

通过运行结果，我们能看到，每次接口的执行实际都是从上次函数调用的中断的地方开始执行的
# 使用限制
协程只有在等待IO的过程中才能重复利用线程，而不能调用阻塞IO。我们知道线程在等待IO的过程中会陷入阻塞状态，如果协程运行在线程之上，并且协程调用了一个阻塞IO操作，实际上因为操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。
因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。
协程对计算密集型的任务也没有太大的好处，计算密集型的任务本身不需要大量的线程切换，因此协程的作用也十分有限，反而还增加了协程切换的开销。
# 小结
有栈协程类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。无栈协程就是类似于线程+状态机，换句话说，其实就是协程的上下文都放到公共内存中，协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。
